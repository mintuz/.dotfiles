Object.defineProperty(exports, '__esModule', {
  value: true
});

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

exports['default'] = addPrepareStackTraceHook;

var PREPARE_STACK_TRACE_HOOKED_KEY = '_nuclide_error_stack_trace_hooked';

var hookedPrepareStackTrace = undefined;

/**
 * v8 provided a way to customize Error stacktrace generation by overwriting
 * Error.prepareStackTrace (https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi).
 * Here we added a hook to Error.prepareStackTrace to achieve following goals:
 *  1) Whenever `error.stack` is called, error.stackTrace will be generated.
 *  2) Other module's customization to Error.prepareStackTrace, no matter before or after the hook
 *     is added, will still work as expected.
 * In this way, other module could still overwrite Error.prepareStackTrace to customize stacktrace.
 * This is required as Atom's builtin coffeescript package need to show coffeescript stacktrace by
 * customize Error.prepareStackTrace.
 */

function addPrepareStackTraceHook() {
  require('../../commons').singleton.get(PREPARE_STACK_TRACE_HOOKED_KEY, function () {
    hookedPrepareStackTrace = createHookedPrepareStackTrace(Error.prepareStackTrace || defaultPrepareStackTrace);

    // Hook Error.prepareStackTrace by leveraging get/set accessor. In this way, writing to
    // Error.prepareStackTrace will put the new prepareStackTrace functions in a wrapper that
    // calls the hook.
    // $FlowIssue
    Object.defineProperty(Error, 'prepareStackTrace', {
      get: function get() {
        return hookedPrepareStackTrace;
      },
      set: function set(newValue) {
        hookedPrepareStackTrace = createHookedPrepareStackTrace(newValue || defaultPrepareStackTrace);
      },
      enumerable: false,
      configurable: true
    });

    // TODO (chenshen) t8789330.
    // Atom added getRawStack to Error.prototype to get Error's structured stacktrace
    // (https://github.com/atom/grim/blob/master/src/grim.coffee#L43). However, this
    // doesn't work well with our customization of stacktrace. So here we temporarily
    // walk around this by following hack, until https://github.com/atom/atom/issues/9641
    // get addressed.
    /* eslint-disable no-extend-native */
    /* $FlowFixMe */
    Error.prototype.getRawStack = null;
    /* eslint-enable no-extend-native */
    return true;
  });
}

/**
 * Create a wrapper that calls to structuredStackTraceHook first, then return the result of
 * prepareStackTrace.
 */
function createHookedPrepareStackTrace(prepareStackTrace) {
  // If the prepareStackTrace is already been hooked, just return it.
  if (prepareStackTrace.name === 'nuclideHookedPrepareStackTrace') {
    return prepareStackTrace;
  }

  var hookedFunction = function nuclideHookedPrepareStackTrace(error, frames) {
    structuredStackTraceHook(error, frames);
    return prepareStackTrace(error, frames);
  };

  return hookedFunction;
}

function structuredStackTraceHook(error, frames) {
  // $FlowFixMe
  error['stackTrace'] = frames.map(function (frame) {
    return {
      functionName: frame.getFunctionName(),
      methodName: frame.getMethodName(),
      fileName: frame.getFileName(),
      lineNumber: frame.getLineNumber(),
      columnNumber: frame.getColumnNumber(),
      evalOrigin: frame.getEvalOrigin(),
      isTopLevel: frame.isToplevel(),
      isEval: frame.isEval(),
      isNative: frame.isNative(),
      isConstructor: frame.isConstructor()
    };
  });
}

function defaultPrepareStackTrace(error, frames) {
  var formattedStackTrace = error.message ? error.name + ': ' + error.message : '' + error.name;
  frames.forEach(function (frame) {
    formattedStackTrace += '\n    at ' + frame.toString();
  });
  return formattedStackTrace;
}

var __test__ = {
  createHookedPrepareStackTrace: createHookedPrepareStackTrace,
  resetPrepareStackTraceHooked: function resetPrepareStackTraceHooked() {
    require('../../commons').singleton.clear(PREPARE_STACK_TRACE_HOOKED_KEY);
  }
};
exports.__test__ = __test__;
//# sourceMappingURL=data:application/json;base64,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QU0sUUFBUSxHQUFHO0FBQ3RCLCtCQUE2QixFQUE3Qiw2QkFBNkI7QUFDN0IsOEJBQTRCLEVBQUEsd0NBQUc7QUFDN0IsV0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztHQUMxRTtDQUNGLENBQUMiLCJmaWxlIjoic3RhY2t0cmFjZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2UgYmFiZWwnO1xuLyogQGZsb3cgKi9cblxuLypcbiAqIENvcHlyaWdodCAoYykgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBsaWNlbnNlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW5cbiAqIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB0eXBlIHtub2RlJENhbGxTaXRlfSBmcm9tICcuL3R5cGVzJztcblxudHlwZSBQcmVwYXJlU3RhY2tUcmFjZUZ1bmN0aW9uID0gKGVycm9yOiBFcnJvciwgZnJhbWVzOiBBcnJheTxub2RlJENhbGxTaXRlPikgPT4gYW55O1xuXG5jb25zdCBQUkVQQVJFX1NUQUNLX1RSQUNFX0hPT0tFRF9LRVkgPSAnX251Y2xpZGVfZXJyb3Jfc3RhY2tfdHJhY2VfaG9va2VkJztcblxubGV0IGhvb2tlZFByZXBhcmVTdGFja1RyYWNlOiA/UHJlcGFyZVN0YWNrVHJhY2VGdW5jdGlvbjtcblxuLyoqXG4gKiB2OCBwcm92aWRlZCBhIHdheSB0byBjdXN0b21pemUgRXJyb3Igc3RhY2t0cmFjZSBnZW5lcmF0aW9uIGJ5IG92ZXJ3cml0aW5nXG4gKiBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSAoaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC93aWtpL0phdmFTY3JpcHRTdGFja1RyYWNlQXBpKS5cbiAqIEhlcmUgd2UgYWRkZWQgYSBob29rIHRvIEVycm9yLnByZXBhcmVTdGFja1RyYWNlIHRvIGFjaGlldmUgZm9sbG93aW5nIGdvYWxzOlxuICogIDEpIFdoZW5ldmVyIGBlcnJvci5zdGFja2AgaXMgY2FsbGVkLCBlcnJvci5zdGFja1RyYWNlIHdpbGwgYmUgZ2VuZXJhdGVkLlxuICogIDIpIE90aGVyIG1vZHVsZSdzIGN1c3RvbWl6YXRpb24gdG8gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UsIG5vIG1hdHRlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGhvb2tcbiAqICAgICBpcyBhZGRlZCwgd2lsbCBzdGlsbCB3b3JrIGFzIGV4cGVjdGVkLlxuICogSW4gdGhpcyB3YXksIG90aGVyIG1vZHVsZSBjb3VsZCBzdGlsbCBvdmVyd3JpdGUgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgdG8gY3VzdG9taXplIHN0YWNrdHJhY2UuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGFzIEF0b20ncyBidWlsdGluIGNvZmZlZXNjcmlwdCBwYWNrYWdlIG5lZWQgdG8gc2hvdyBjb2ZmZWVzY3JpcHQgc3RhY2t0cmFjZSBieVxuICogY3VzdG9taXplIEVycm9yLnByZXBhcmVTdGFja1RyYWNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhZGRQcmVwYXJlU3RhY2tUcmFjZUhvb2soKTogdm9pZCB7XG4gIHJlcXVpcmUoJy4uLy4uL2NvbW1vbnMnKS5zaW5nbGV0b24uZ2V0KFxuICAgIFBSRVBBUkVfU1RBQ0tfVFJBQ0VfSE9PS0VEX0tFWSxcbiAgICAoKSA9PiB7XG4gICAgICBob29rZWRQcmVwYXJlU3RhY2tUcmFjZSA9IGNyZWF0ZUhvb2tlZFByZXBhcmVTdGFja1RyYWNlKEVycm9yLnByZXBhcmVTdGFja1RyYWNlXG4gICAgICAgIHx8IGRlZmF1bHRQcmVwYXJlU3RhY2tUcmFjZSk7XG5cbiAgICAgIC8vIEhvb2sgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgYnkgbGV2ZXJhZ2luZyBnZXQvc2V0IGFjY2Vzc29yLiBJbiB0aGlzIHdheSwgd3JpdGluZyB0b1xuICAgICAgLy8gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2Ugd2lsbCBwdXQgdGhlIG5ldyBwcmVwYXJlU3RhY2tUcmFjZSBmdW5jdGlvbnMgaW4gYSB3cmFwcGVyIHRoYXRcbiAgICAgIC8vIGNhbGxzIHRoZSBob29rLlxuICAgICAgLy8gJEZsb3dJc3N1ZVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yLCAncHJlcGFyZVN0YWNrVHJhY2UnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gaG9va2VkUHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgICAgIGhvb2tlZFByZXBhcmVTdGFja1RyYWNlID0gY3JlYXRlSG9va2VkUHJlcGFyZVN0YWNrVHJhY2UobmV3VmFsdWVcbiAgICAgICAgICAgIHx8IGRlZmF1bHRQcmVwYXJlU3RhY2tUcmFjZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgLy8gVE9ETyAoY2hlbnNoZW4pIHQ4Nzg5MzMwLlxuICAgICAgLy8gQXRvbSBhZGRlZCBnZXRSYXdTdGFjayB0byBFcnJvci5wcm90b3R5cGUgdG8gZ2V0IEVycm9yJ3Mgc3RydWN0dXJlZCBzdGFja3RyYWNlXG4gICAgICAvLyAoaHR0cHM6Ly9naXRodWIuY29tL2F0b20vZ3JpbS9ibG9iL21hc3Rlci9zcmMvZ3JpbS5jb2ZmZWUjTDQzKS4gSG93ZXZlciwgdGhpc1xuICAgICAgLy8gZG9lc24ndCB3b3JrIHdlbGwgd2l0aCBvdXIgY3VzdG9taXphdGlvbiBvZiBzdGFja3RyYWNlLiBTbyBoZXJlIHdlIHRlbXBvcmFyaWx5XG4gICAgICAvLyB3YWxrIGFyb3VuZCB0aGlzIGJ5IGZvbGxvd2luZyBoYWNrLCB1bnRpbCBodHRwczovL2dpdGh1Yi5jb20vYXRvbS9hdG9tL2lzc3Vlcy85NjQxXG4gICAgICAvLyBnZXQgYWRkcmVzc2VkLlxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuICAgICAgLyogJEZsb3dGaXhNZSAqL1xuICAgICAgRXJyb3IucHJvdG90eXBlLmdldFJhd1N0YWNrID0gbnVsbDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSB3cmFwcGVyIHRoYXQgY2FsbHMgdG8gc3RydWN0dXJlZFN0YWNrVHJhY2VIb29rIGZpcnN0LCB0aGVuIHJldHVybiB0aGUgcmVzdWx0IG9mXG4gKiBwcmVwYXJlU3RhY2tUcmFjZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSG9va2VkUHJlcGFyZVN0YWNrVHJhY2UoXG4gIHByZXBhcmVTdGFja1RyYWNlOiBQcmVwYXJlU3RhY2tUcmFjZUZ1bmN0aW9uLFxuKTogUHJlcGFyZVN0YWNrVHJhY2VGdW5jdGlvbiB7XG4gIC8vIElmIHRoZSBwcmVwYXJlU3RhY2tUcmFjZSBpcyBhbHJlYWR5IGJlZW4gaG9va2VkLCBqdXN0IHJldHVybiBpdC5cbiAgaWYgKHByZXBhcmVTdGFja1RyYWNlLm5hbWUgPT09ICdudWNsaWRlSG9va2VkUHJlcGFyZVN0YWNrVHJhY2UnKSB7XG4gICAgcmV0dXJuIHByZXBhcmVTdGFja1RyYWNlO1xuICB9XG5cbiAgY29uc3QgaG9va2VkRnVuY3Rpb24gPSBmdW5jdGlvbiBudWNsaWRlSG9va2VkUHJlcGFyZVN0YWNrVHJhY2UoXG4gICAgZXJyb3I6IEVycm9yLFxuICAgIGZyYW1lczogQXJyYXk8bm9kZSRDYWxsU2l0ZT4sXG4gICk6IGFueSB7XG4gICAgc3RydWN0dXJlZFN0YWNrVHJhY2VIb29rKGVycm9yLCBmcmFtZXMpO1xuICAgIHJldHVybiBwcmVwYXJlU3RhY2tUcmFjZShlcnJvciwgZnJhbWVzKTtcbiAgfTtcblxuICByZXR1cm4gaG9va2VkRnVuY3Rpb247XG59XG5cbmZ1bmN0aW9uIHN0cnVjdHVyZWRTdGFja1RyYWNlSG9vayhlcnJvcjogRXJyb3IsIGZyYW1lczogQXJyYXk8bm9kZSRDYWxsU2l0ZT4pOiB2b2lkIHtcbiAgLy8gJEZsb3dGaXhNZVxuICBlcnJvclsnc3RhY2tUcmFjZSddID0gZnJhbWVzLm1hcChmcmFtZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZ1bmN0aW9uTmFtZTogZnJhbWUuZ2V0RnVuY3Rpb25OYW1lKCksXG4gICAgICBtZXRob2ROYW1lOiBmcmFtZS5nZXRNZXRob2ROYW1lKCksXG4gICAgICBmaWxlTmFtZTogZnJhbWUuZ2V0RmlsZU5hbWUoKSxcbiAgICAgIGxpbmVOdW1iZXI6IGZyYW1lLmdldExpbmVOdW1iZXIoKSxcbiAgICAgIGNvbHVtbk51bWJlcjogZnJhbWUuZ2V0Q29sdW1uTnVtYmVyKCksXG4gICAgICBldmFsT3JpZ2luOiBmcmFtZS5nZXRFdmFsT3JpZ2luKCksXG4gICAgICBpc1RvcExldmVsOiBmcmFtZS5pc1RvcGxldmVsKCksXG4gICAgICBpc0V2YWw6IGZyYW1lLmlzRXZhbCgpLFxuICAgICAgaXNOYXRpdmU6IGZyYW1lLmlzTmF0aXZlKCksXG4gICAgICBpc0NvbnN0cnVjdG9yOiBmcmFtZS5pc0NvbnN0cnVjdG9yKCksXG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQcmVwYXJlU3RhY2tUcmFjZShlcnJvcjogRXJyb3IsIGZyYW1lczogQXJyYXk8bm9kZSRDYWxsU2l0ZT4pOiBzdHJpbmcge1xuICBsZXQgZm9ybWF0dGVkU3RhY2tUcmFjZSA9IGVycm9yLm1lc3NhZ2UgPyBgJHtlcnJvci5uYW1lfTogJHtlcnJvci5tZXNzYWdlfWAgOiBgJHtlcnJvci5uYW1lfWA7XG4gIGZyYW1lcy5mb3JFYWNoKGZyYW1lID0+IHtcbiAgICBmb3JtYXR0ZWRTdGFja1RyYWNlICs9IGBcXG4gICAgYXQgJHtmcmFtZS50b1N0cmluZygpfWA7XG4gIH0pO1xuICByZXR1cm4gZm9ybWF0dGVkU3RhY2tUcmFjZTtcbn1cblxuZXhwb3J0IGNvbnN0IF9fdGVzdF9fID0ge1xuICBjcmVhdGVIb29rZWRQcmVwYXJlU3RhY2tUcmFjZSxcbiAgcmVzZXRQcmVwYXJlU3RhY2tUcmFjZUhvb2tlZCgpIHtcbiAgICByZXF1aXJlKCcuLi8uLi9jb21tb25zJykuc2luZ2xldG9uLmNsZWFyKFBSRVBBUkVfU1RBQ0tfVFJBQ0VfSE9PS0VEX0tFWSk7XG4gIH0sXG59O1xuIl19